import 'utils.eol';

rule StateMachine2JavaClass
  transform sm: Source!StateMachine
  to jc: Target!JavaClass,
     processMethod: Target!Method,
     tp: Target!Parameter,
     invoke: Target!MethodInvocation
{
  jc.name = sm.name;
  jc.methods.add(processMethod);
  jc.methods.addAll(sm.states.collect(s|s.equivalent()));

  // Adds a 'public process(String text)' method, which calls the initial state
  processMethod.name = 'process';
  processMethod.visibility = Target!MethodVisibility#PUBLIC;
  processMethod.parameters.add(tp);
  tp.name = 'text';

  processMethod.statements.add(invoke);
  invoke.methodByRef = sm.initialState.equivalent().selectOne(e|e.isKindOf(Target!Method));
  invoke.arguments.add(parameterReference(tp));
}

@abstract
rule State2Method
  transform s : Source!State
  to m: Target!Method, tp: Target!Parameter,
     ifNotEmpty: Target!IfStatement
{
  m.name = s.methodName();
  m.visibility = Target!MethodVisibility#PROTECTED;

  m.parameters.add(tp);
  tp.name = 'text';

  m.statements.add(ifNotEmpty);

  // If the text is not empty...
  ifNotEmpty.condition = logicalNot(methodInvocation(parameterReference(tp), 'isEmpty', Sequence {}));

  // Add error if we haven't moved to another state by now
  ifNotEmpty.statements.add(throwStatement(newInstance('IllegalStateException', Sequence {
    methodInvocation(null, 'String.format', Sequence {
      stringConstant('State "' + s.name + '": no valid outgoing transition for "%s"'),
      parameterReference(tp)
    })
  })));
}

rule State2MethodNoTransitions
  transform s : Source!State
  to m: Target!Method, tp: Target!Parameter,
     ifNotEmpty: Target!IfStatement
  extends State2Method
{
  guard: s.outgoing.isEmpty()
}

rule State2MethodWithTransitions
  transform s : Source!State
  to m: Target!Method, tp: Target!Parameter,
     ifNotEmpty: Target!IfStatement,
     cDeclaration: Target!VariableDeclaration,
     restDeclaration: Target!VariableDeclaration
  extends State2Method
{
  guard: not s.outgoing.isEmpty()

  // Fetch the first character
  cDeclaration.type = 'char';
  cDeclaration.name = 'c';
  cDeclaration.initializer = methodInvocation(parameterReference(tp), 'charAt', Sequence { integerConstant(0) });

  // Put the rest of the string in another variable
  restDeclaration.type = 'String';
  restDeclaration.name = 'rest';
  restDeclaration.initializer = methodInvocation(parameterReference(tp), 'substring', Sequence { integerConstant(1) });

  // Add transitions
  var throwStmt = ifNotEmpty.statements.first;
  ifNotEmpty.statements.clear();
  ifNotEmpty.statements.add(cDeclaration);
  ifNotEmpty.statements.add(restDeclaration);
  ifNotEmpty.statements.addAll(s.outgoing.collect(o|o.equivalent()));
  ifNotEmpty.statements.add(throwStmt);
}

@abstract
rule TransitionToStatement
  transform tr: Source!Transition
  to ifStmt: Target!IfStatement, methodInvocation: Target!MethodInvocation, retStmt: Target!ReturnStatement
{
  var cDeclaration = tr.from.equivalents().selectOne(e | e.isKindOf(Target!VariableDeclaration) and e.name = 'c');
  var restDeclaration = tr.from.equivalents().selectOne(e | e.isKindOf(Target!VariableDeclaration) and e.name = 'rest');

  tr.~cDeclaration = cDeclaration;
  tr.~restDeclaration = restDeclaration;

  ifStmt.statements.add(methodInvocation);
  ifStmt.statements.add(retStmt);
  methodInvocation.methodByRef = tr.`to`.equivalent();
  methodInvocation.arguments.add(variableReference(restDeclaration));
}

rule SingleCharacterTransition
  transform tr: Source!Transition
  to ifStmt: Target!IfStatement, methodInvocation: Target!MethodInvocation, retStmt: Target!ReturnStatement
  extends TransitionToStatement
{
  guard: tr.characterRange.matches("\\w")

  ifStmt.condition = equals(variableReference(tr.~cDeclaration), characterConstant(tr.characterRange));
}

rule CharacterRangeTransition
  transform tr: Source!Transition
  to ifStmt: Target!IfStatement, methodInvocation: Target!MethodInvocation, retStmt: Target!ReturnStatement
  extends TransitionToStatement
{
  guard: tr.characterRange.matches("\\w-\\w")

  ifStmt.condition = logicalAnd(
    gte(variableReference(tr.~cDeclaration), characterConstant(tr.characterRange.charAt(0).toString())),
    lte(variableReference(tr.~cDeclaration), characterConstant(tr.characterRange.charAt(2).toString()))
  );
}